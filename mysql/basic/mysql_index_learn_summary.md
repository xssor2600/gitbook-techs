##### 索引概念
> 官方对索引的定义

索引是帮助mysql高效获取数据的数据结构。（索引的本质：索引是数据结构，排好序的快速查找的数据结构）

**mysql支持那些数据结构可以作为索引数据结构？**

- **BTree索引**
- Hash索引
- Full-Text全文索引
- R-Tree索引

哈希(hash)比树(tree)更快，索引结构为什么要设计成树型？

1. 哈希： 例如HashMap,增删改查的平均时间复杂度都是O(1)。
2. 树：例如平衡二叉搜索树，增删改查平均时间复杂度是O(lg(n))。

**设计成树型和SQL的需求会影响哈希的时间复杂度有关系。**

对于这样一个单行查询的SQL需求：	`select * from t where name=”shenjian”;`确实是哈希索引更快，因为每次都只查询一条记录,

但是对于排序查询的SQL需求：例如分组，排序，比较等等，哈希型索引，时间复杂度会退化为O(n)，而有型的树形的“有序”特性,依然能够保持O(log(n))的高效率。（任何脱离需求的设计都是耍流氓）


> 为什么需要索引？

索引的目的在于提高查询效率，可以类比为字典，目录。**（影响查找和排序）**
数据本身之外，数据库还维护一个满足特定查找算法的数据结构，这种这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法。这种数据结构就是索引。`（数据结构 --> 数据）`

- 一些问题思考
	- 索引是否创建了就生效？有什么规则？创建了索引，在数据不断变动增多（增删改），字段变更的情况下，是否会影响索引效率？
	- 索引是以什么形似保存在mysql数据库中？
		索引这种数据结构是以指定格式文件的形式存储在磁盘上进行持久化。在使用的时候，会根据策略还在到内存中。
		对数据库的更新操作后，需要维护数据和索引关系。（因为索引是指向实际数据的数据结构）
		

> 索引类型？

1. 单值类型： 一个索引只是包含单个列，一个表可以有多个单列索引。
2. 唯一索引： 索引列的值必须唯一，但是允许有空值。
3. 复合索引： 一个索引包含多个列。



> 索引失效的原因？（失效原因于执行计划有关系）







> 数据库索引使用树形结构，为什么使用B+树？

- **二叉查找树（BST）**

  通常又称作`二叉排序树`,即为右子树值>根节点>左子树。每个节点下最多只能有两个子节点。

  它为什么不适合用作数据库索引？

  1. 当数据量大的时候，**树的高度会比较高**，数据量大的时候，查询会比较慢；
  2. 每个节点只存储一个记录，**可能导致一次查询有很多次磁盘IO**；

- **B树**（多叉查找树）

  一棵m阶B树(balanced tree of order m)是一棵`平衡的m路搜索树`。与二叉树不同，该树是m叉树，即为一个节点下可以分叉出多个节点，存储数量上比二叉树多了很多，压缩了树高。
  ![image](https://bkimg.cdn.bcebos.com/pic/4e4a20a4462309f773bdc15d720e0cf3d6cad6ab?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5)

  B树特点：

  1. 不在是二叉树，而是m叉树。
  2. 叶子结点，非叶子结点都可以存储数据。
  3. 中序遍历，可以获得所有节点。

  B树被作为实现索引的数据结构被创造出来，是因为它能够完美的利用“**局部性原理**”。

  局部性原理的逻辑是这样的：

  1. 内存读写块，磁盘读写慢，而且慢很多；
  2. **磁盘预读**：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，每次加载更多的数据，如果未来要读取的数据就在这一页中，可以避免未来的磁盘IO，提高效率；

  *通常，一页数据是4K。*

- **B+树**
  仍是m叉搜索树，在B树的基础上，做了一些改进：

  1. 非叶子结点不存储数据，数据只是存储在同一层的叶子结点上。（**B+树中根到每一个节点的路径长度一样，而B树不是这样**。）
  2. **叶子之间，增加了链表**，获取所有节点，不再需要中序遍历；

  ![image](https://bkimg.cdn.bcebos.com/pic/2cf5e0fe9925bc317a17582556df8db1ca1370c0?x-bce-process=image/crop,x_24,y_0,w_562,h_372/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5)

**所有的叶子结点中包含了全部关键字的信息**，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接

这些改进在数据库查询哪些特性上表现出更优：

- 范围查找，在定位起始和结束两端之后，中间的叶子结点，就是结果集，不用中序回溯。
- 叶子结点存储实际行记录，记录行相对比较紧密的存储，适合存储大数据量的磁盘存储；非叶子结点存储记录的PK，用于查询加速，适合内存存储。
- 非叶子结点，不存储实际记录，只是存储记录的`key`的话，那么在相同内存的情况下，B+树可以存储更多索引。

**量化说下，为什么m叉的B+树比二叉搜索树的高度大大大大降低？**

1. 局部性原理，将一个节点的大小设为一页，一页4K，假设一个KEY有8字节，一个节点可以存储500个KEY，即j=500
2. m叉树，大概m/2<= j <=m，即可以差不多是1000叉树
3. 那么：
   一层树：1个节点，1*500个KEY，大小4K
   二层树：1000个节点，1000*500=50W个KEY，大小1000*4K=4M
   三层树：1000*1000个节点，1000*1000*500=5亿个KEY，大小1000*1000*4K=4G
   可以看到，存储大量的数据（5亿），并不需要太高树的深度（高度3），索引也不是太占内存（4G）。



重点概念：局部性原理

> 局部性原理：软件设计要尽量遵循“数据读取集中”与“使用到一个数据，大概率会使用其附近的数据”，这样磁盘预读能充分提高磁盘IO

数据库的索引最常用B+树：

- 适合做磁盘存储，能够充分利用局部性原理，做磁盘预读。（按页读取）
- 很低的树高度，能够存储大量的数据
- 索引本身占用内存很小
- 能够很好支持单点查询，范围查询，有序查询。



> 不同索引在实际数据库存储中的应用

可以用于提高读写效率的数据结构很多，先看三种常见、也比较简单的数据结构，它们分别是`哈希表`、`有序数组`和`搜索树`。

【核心点： **是否有序、范围区间查询、查询复杂度**】

- 哈希表

  键-值（key-value）存储数据的结构。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。

  eg: 维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示： 

  **数组X[`hash(身份证号)` ] = 用户信息（身份证号、名字）**

  ![image](https://s3.ax1x.com/2021/01/15/sw0lBq.png)

  假设，这时候你要查ID_card_n2对应的名字是什么，处理步骤就是：首先，将ID_card_n2通过哈希函数算出N；然后，按顺序遍历，找到User2。

  **因为KEY值映射后得到的桶位置是无序的，所以哈希索引做区间范围查询速度是很慢的。**哈希表这种结构适用于只有等值查询的场景，比如Memcached及其他一些NoSQL引擎。

  

- 有序数组

  有序数组在等值查询和范围查询场景中的性能就都非常优秀。

  ![image](https://s3.ax1x.com/2021/01/15/sw0T58.png)

  这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查ID_card_n2对应的名字，用二分法就可以快速得到，这个时间复杂度是O(log(N))。

  数组查询效率最高，但是**需要更新数据成本就很高**。需要批量变更数据索引位置。

  **有序数组索引只适用于静态存储引擎**，比如你要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。

  

- N叉搜索树

  ![image](https://s3.ax1x.com/2021/01/15/swBxQH.png)

  二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查ID_card_n2的话，按照图中的搜索顺序就是按照UserA -> UserC -> UserF -> User2这个路径得到。这个时间复杂度是O(log(N))。

  二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，**索引不止存在内存中，还要写到磁盘上**。

  

  N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。

  

  



##### B+索引树

在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。

```
每一个索引在InnoDB里面对应一棵B+树。
主键索引也不例外，也对应这一棵B+树，该树比较特别，叶子节点储存行记录。称为聚簇索引
```

假设我们有一个主键列为ID的表，表中有字段k，并且在k上有索引。

```sql
create table T(
id int primary key, 
k int not null, 
name varchar(16),
index (k))engine=InnoDB;
```

表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下。

![image](https://s3.ax1x.com/2021/01/15/swrVN6.png)

索引类型分为`主键索引`和`非主键索引`。

- 主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为`聚簇索引`（clustered index）。
- 非主键索引的叶子节点内容是**主键的值**。在InnoDB里，非主键索引也被称为`二级索引`（secondary index）。



**基于主键索引和普通索引的查询有什么区别？**

- 基于主键索引和普通索引的查询有什么区别？
- 如果语句是select * from T where k=5，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为`回表`。



**表的索引可以有SQL语句进行变更，那么必然会对索引进行维护？索引是否有序？**

如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。

而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为**页分裂** 。在这种情况下，性能自然会受影响

当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。

显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。



再看看另外一个例子

```sql
create table T (
ID int primary key,
k int NOT NULL DEFAULT 0, 
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;
insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
```

`select * from T where k between 3 and 5`，需要执行几次树的搜索操作，会扫描多少行？

1. 在k索引树上找到k=3的记录，取得 ID = 300
2. 再到ID索引树查到ID=300对应的R3；
3. 在k索引树取下一个值k=5，取得ID=500；
4. 再回到ID索引树查到ID=500对应的R4；
5. 在k索引树取下一个值k=6，不满足条件，循环结束。

在这个过程中，回到主键索引树搜索的过程，我们称为回表。可以看到，这个查询过程读了k索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。



**有什么其他优化的索引可以避免回表查询？**

还是有的，因为非聚簇索引的叶子节点上保存着主键值，若是sql仅仅是查询主键值，而不是记录的其他值。那么就可以不进行回表查询操作。

```sql
select ID from T where k between 3 and 5
```

这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引。

由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。

---



> **最左前缀原则**

B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。**索引项是按照索引定义里面出现的字段顺序排序的。**

```sql
CREATE TABLE `tuser` (
  `id` int(11) NOT NULL,
  `id_card` varchar(32) DEFAULT NULL,
  `name` varchar(32) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `ismale` tinyint(1) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `id_card` (`id_card`),
  KEY `name_age` (`name`,`age`)
) ENGINE=InnoDB
```

用（name，age）这个联合索引来分析:

![image](https://s3.ax1x.com/2021/01/15/sw6sUI.png)

当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。

你的SQL语句的条件是`"where name like ‘张%’"`。这时，你也能够用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历，直到不满足条件为止。

```
可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。
```

最左原则说明一个问题：  **创建表定义的索引字段的顺序是会影响查询性能的**。



**所以，在建立联合索引时候，如何定义联合索引位置顺序？**

这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。当在索引字段选择时候，还得考虑空间问题，尽量选择占用字段少的列作为索引列



> **索引下推**

上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能要问，那些不符合最左前缀的部分，会怎么样呢？

联合索引（name, age）为例，检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩”。那么，SQL语句是这么写的：

```sql
mysql> select * from tuser where name like '张%' and age=10 and ismale=1;
```

最左前缀原则，先通过最左索引name查找所有名字以张开头的人数据得到主键ID（二级索引叶子节点）,效率比全表扫描要好。

之后获取到主键ID记录又该如何匹配后面的属性值？

- **在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。**

  这个过程InnoDB并不会去看age的值，只是按顺序把“name第一个字是’张’”的记录一条条取出来回表。因此，需要回表4次。

  [仅仅只是根据二级复合索引的部分索引值进行查询判断，**where后面的条件判断都会去之主键索引获取record记录后进行判断**]

- MySQL 5.6 引入的**索引下推优化**（index condition pushdown)， 可以在索引遍历过程中，`对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数`。

  InnoDB在(name,age)**索引内部就判断了age是否等于10**，对于不等于10的记录，直接判断并跳过。在我们的这个例子中，只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表2次。

  根据最大覆盖索引原则，将where后面条件在二级索引树中进行过滤，得到满足的主键再去主键索引表。



---



**InnodDB与B+索引树**

InnodDB磁盘读写机制：

InnoDB的数据是按`数据页为单位来读写`的，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。(在InnoDB中，每个数据页的大小默认是**16KB**。)

**那么B+树上的节点数据是否也是对应一个块数据？索引树存储内容和表记录、磁盘页数据有什么关系？**

`情况1: 当在内存中查找不到指定记录的时候，需要进行磁盘IO加载数据页进行内存`

当查询k=5的记录时候，会有两种情况：当前记录所在的页是否在内存中或者磁盘中。

当找到k=5的记录的时候，它所在的数据页就都在内存里了。由于普通索引还需要继续遍历查找，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。若是在内存中找不到记录，则需要从磁盘按照数据页进行加载入内存。

`情况2:数据的更新涉及到索引变更，也会影响数据刷入磁盘`

更新的过程，需要先读取，在更新。并不是一个原子操作，分为两阶段锁协议。通过当前读得到记录加上排它锁，后进行数据变更操作，完成提交事务后，释放锁。所以，更新操作涉及查询，也会有数据所属数据页是否基因加载到内存中还是在磁盘中的问题。



引出**change buffer**概念

A. 更新数据页记录 ⇒ 数据页在内存中直接更新 

B. 不在内存中，在不影响数据一致性情况下，InnodDB将更新操作（sql record)缓存在change buffer中，就不需要进行IO读取页。

change buffer占用的内存是属于buffer pool中的一部分。

>change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。

**因为修改记录保存在change buffer中，没有持久化同步更新到磁盘上。如果这时候又要对变更的记录进行查询？**

将change buffer中的操作应用到原数据页，得到最新结果的过程称为`merge`。

merge的执行流程是这样的：

1. 从磁盘读入数据页到内存（老版本的数据页）；
2. 从change buffer里找出这个数据页的change buffer 记录(可能有多个），依次应用，得到新版数据页；
3. 写redo log。**这个redo log包含了数据的变更和change buffer的变更。**

到这里merge过程就结束了。这时候，数据页和内存中change buffer对应的磁盘位置都还没有修改，属于脏页，之后各自刷回自己的物理数据，就是另外一个过程了。

merge处理：（并不包括刷新写会物理磁盘过程）

1. 当访问这个数据页的时候就会触发merge。将变更应用到加载到内存的数据页，返回最新数据。
2. 系统后台线程定时merge操作。
3. 在数据库正常关闭(shutdown)也会执行merge.





> **更新使用change buffer有什么好处？**

将变更先保存与change buffer，避免了再次磁盘数据页加载内存，减少读磁盘。

那么语句执行速度会得到明显提升;减少buffer pool内存大小（加载数据页到buffer pool）



> **依据change buffer机制，和唯一索引、普通索引之间有什么关系？**

假设数据库表T一共有200数据块数据，表数据存储在这200数据块中。其中20个数据块加载到内存buffer pool中。

对于唯一索引来说，若是要更新还是插入记录x，要确保内存中的20个数据块与磁盘上的180个数据块中都没有相同唯一索引的记录。所以，唯一索引需要校验变更操作是否违反唯一性约束。

1. 对于唯一索引，若是插入记录，则必须是内存中和磁盘中的数据都要进行唯一性约束判断。
2. 对于更新操作，若是记录在当前内存数据页中，则直接操作判断变更，若是不在，则需要加载磁盘数据页进行判断。

所以，唯一索引更新不能使用change bufer。只有非唯一索引才可以使用。



> **change buffer的使用场景**

1. 对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好.
2. 反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。



> **change buffer 和 redo log关系？**

Redo log中会包含change buffer修改内容，在redo log将更新更新入磁盘会将更新持久化。

```sql
insert into t(id,k) values(id1,k1),(id2,k2);
```

当前k索引树的状态，查找到位置后，k1所在的数据页在内存(InnoDB buffer pool)中，k2所在的数据页不在内存中。

![image](https://s3.ax1x.com/2021/01/15/swxHBQ.png)



内存（buffer pool)、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）。

1. Page 1在内存中，直接更新内存；
2. Page 2没有在内存中，就在内存的change buffer区域，记录下“我要往Page 2插入一行”这个信息
3. 将上述两个动作记入redo log中（图中3和4）。

图中的两个虚线箭头，是后台操作，不影响更新的响应时间。



**若是在更新后马上就查询，内部如何处理？**

```sql
select * from t where k in (k1, k2)
```

![image](https://s3.ax1x.com/2021/01/15/swzT8x.png)

1. 读Page 1的时候，直接从内存返回。WAL之后如果读数据，是不是一定要读盘，是不是一定要从redo log里面把数据更新以后才可以返回？其实是不用的。
2. 要读Page 2的时候，需要把Page 2从磁盘读入内存中，然后应用change buffer里面的操作日志，生成一个正确的版本并返回结果。

可以看到，直到需要读Page 2的时候，这个数据页才会被读入内存。

简单地对比这两个机制在提升更新性能上的收益的话:

-  redo log 主要节省的是随机写磁盘的IO消耗（转成顺序写）
- change buffer主要节省的则是随机读磁盘的IO消耗。



**脏页刷新磁盘**

在回顾下`WAL`机制：InnoDB在处理更新语句的时候，**只做了写日志这一个磁盘操作。这个日志叫作redo log**（重做日志）,在更新内存写完redo log后，就返回给客户端，本次更新成功。（**并没有直接每次都将更新操作都写入磁盘数据页**）

> 把内存里的数据写入磁盘的过程，术语就是flush

当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为`“脏页”`。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。

平时执行很快的更新操作，其实就是在写内存和日志，而MySQL偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。

**那么，什么情况会引发数据库的flush过程呢？**

思考要从正常和异常情况下考虑: 正常如系统空闲，数据库连接关闭；异常如数据库宕机，业务高频，日志写满，内存不足等等。

- InnoDB的redo log写满了。这时候系统会停止所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写。

  ![image](https://s3.ax1x.com/2021/01/15/s0nYRS.png)

  把checkpoint位置从CP推进到CP’，就需要将两个点之间的日志（浅绿色部分），对应的所有脏页都flush到磁盘上。

  

- 系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。
  从性能考虑的。如果刷脏页一定会写盘，就保证了每个数据页有两种状态：

  1. 一种是内存里存在，内存里就肯定是正确的结果，直接返回；
  2. 另一种是内存里没有数据，就可以肯定数据文件上是正确的结果，读入内存后返回。这样的效率最高。

- MySQL认为系统“空闲”的时候。合理地安排时间，只要有机会就刷一点“脏页”。
- 是MySQL正常关闭的情况。MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。



**分析几种情况性能？**

1. redo log写满了，要flush脏页。这种情况是InnoDB要尽量避免的。因为出现这种情况的时候，整个系统就不能再接受更新了，所有的更新都必须堵住。

2. 内存不够用了，要先将脏页写到磁盘，这种情况其实是常态。

   InnoDB用缓冲池（`buffer pool`）管理内存，缓冲池中的内存页有三种状态：

   - 还没有使用的；
   - 使用了并且是干净页；
   - 使用了并且是脏页。

   而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉。如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。



什么情况下的刷脏会明显影响数据库性能？

1. 一个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；
2. redo log日志写满，更新全部堵住，写性能跌为0，这种情况对敏感业务来说，是不能接受的。



**InnoDB刷脏页的控制策略**

InnodDB控制策略依赖于告知InnodDB的系统主机的IO能力。这就要用到innodb_io_capacity这个参数了，它会告诉InnoDB你的磁盘能力。这个值我建议你设置成磁盘的IOPS。

```sql
fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest
```

当将脏页flush到磁盘后，同时也会将redo log上涉及到的记录给擦除。（**向前移动checkpoint**)

所以，InnoDB的刷盘速度就是要参考这两个因素：**一个是脏页比例，一个是redo log写盘速度。**

- innodb_max_dirty_pages_pct是脏页比例上限，默认值是75%.
- innodb_io_capacity 主机IO能力

```sql
mysql> show variables like '%dirty%';
+--------------------------------+-------+
| Variable_name                  | Value |
+--------------------------------+-------+
| innodb_max_dirty_pages_pct     | 75    |
| innodb_max_dirty_pages_pct_lwm | 0     |
+--------------------------------+-------+
2 rows in set (0.00 sec)

mysql> show variables like '%capacity%';
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| innodb_io_capacity     | 200   |
| innodb_io_capacity_max | 2000  |
+------------------------+-------+
2 rows in set (0.01 sec)
```

合理地设置innodb_io_capacity的值，并且平时要多关注脏页比例，不要让它经常接近75%。





##### InnoDB 缓冲池

![image](https://s3.ax1x.com/2021/01/15/s0QMSf.png)

MySQL数据存储包含内存与磁盘两个部分； 

**内存缓冲池(buffer pool)以页为单位，缓存最热的数据页(data page)与索引页(index page)**； InnoDB以变种LRU算法管理缓冲池，并能够解决“预读失效”与“缓冲池污染”的问题；

>  InnoDB的缓冲池缓存什么?有什么用?

缓冲池缓存: 表数据(热点部分) + 索引数据.   目的:降低磁盘访问.

把磁盘上数据加载到缓冲池( 文件 → 内存),避免每次访问都进行磁盘IO,起到加速访问的作用.(前提是命中热点数据)



> InnoDB缓冲池中保存数据的最小单位是什么?数据结构?如何管理？

innodb_page_size配置选项来配置mysql实例中所有innodb表空间的页大小。16K是默认设置大小。详情：[innodb_page_size](https://dev.mysql.com/doc/refman/5.7/en/server-status-variables.html#statvar_Innodb_page_size)

缓冲区通常是以: `页链表`数据结构来对缓存数据进行处理和操作.

缓冲区内页链表的载入和淘汰管理都有一套算法. **缓存页数据保存如缓冲区叫预读**.(缓存数据页+缓存索引页)

```
磁盘读写数据,并不是按需读取(懒读取),而是按页读取.若是后续要读取数据就在页中,就算命中缓冲区,避免了再次的磁盘文件IO读取数据.
数据访问,遵循“集中读写”原则,使用一些数据,大概率会使用附近的数据,就是所谓的“局部性原理”.
```

数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。



InnoDB是以什么算法，来管理这些缓冲页呢？

最容易想到的，就是LRU(Least recently used)。[最近最少使用]

传统的LRU缓冲池算法十分直观，OS，memcache等很多软件都在用，MySQL为啥这么矫情，不能直接用呢？

1. 预读失效；
   由于预读(Read-Ahead)，提前把页放入了缓冲池，但最终MySQL并没有从页中读取数据，称为预读失效。要优化预读失效，思路是：

   （1）让预读失败的页，停留在缓冲池LRU里的时间尽可能短；

   （2）让真正被读取的页，才挪到缓冲池LRU的头部；

2. 缓冲池污染；

   当某一个SQL语句，要批量扫描大量数据时，可能导致把缓冲池的所有页都替换出去，导致大量热数据被换出，MySQL性能急剧下降，这种情况叫缓冲池污染。

**InnoDB对普通LRU进行了优化：**

- 将缓冲池分为**老生代和新生代**，入缓冲池的页，优先进入老生代，页被访问，才进入新生代，以解决预读失效的问题
- 页被访问，且在老生代**停留时间超过配置阈值**的，才进入新生代，以解决批量数据访问，大量热数据淘汰的问题



参考：[MySQL Innodb 数据页结构分析](https://www.cnblogs.com/bdsir/p/8745553.html)







##### 执行计划

**`explain`是什么？**

使用explain可以模拟优化执行器执行sql查询语句，从而知道mysql是如何处理sql语句的，进而可以分析查询语句是表结构性能还是其他原因。

可以做些什么？

1. 查看SQL执行过程读区表的顺序
2. 数据读取索引操作类型
3. 那些索引被优化器使用了
4. 表之间的引用关系，每张表有多少行被查询
5. 。。。



**explain组成**

```sql
explain select * from tsmall;
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
| id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | product | ALL  | NULL          | NULL | NULL    | NULL |   16 |       |
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
```

- **id(表查询顺序)**

  select查询的序列号，包含一组数字，表示查询中执行select子句或者操作表的顺序。

  1. ID相同,执行顺序由上到下
     ![image](https://s3.ax1x.com/2021/01/15/s09eg0.png)

  2. ID不同，如果是自查询，ID的序号会递增，ID值最大优先级越高，越先被执行

     ![image](https://s3.ax1x.com/2021/01/15/s094aQ.png)

  3. ID不相同，同时存在

  4. derived2表示从ID=2的查询语句衍生出来的表。

     ![image](https://s3.ax1x.com/2021/01/15/s09Hx0.png)

- **Select_type**

  查询类型，表示查询类型，主要是用于区别：普通查询，联合查询，子查询等复杂查询Mysql中查询类型有以下几种：

  1. SIMPLE

     简单的select查询，查询中不包含自查询或者UNION

  2. PRIMARY

     查询中若是包含任何复杂的子部分，最外层查询则被标记为primary

  3. SUBQUERY
     在select或者where列表中包含了子查询

  4. DERIVED
     在from列表中包含的自查询被标记为derived衍生，mysql会递归执行这些子查询，把结果放在临时表内

  5. UNION
     若是第二个select出现在union之后，则被标记为union

  6. UNION RESULT
     从union表结构中获取得到的结果

- **Type**

  显示查询使用了何种类型（从好到差排序）`system>const>eq_ref>ref>range>index>ALL`

  一般来说，得保证查询至少达到range级别，最好达到ref。

  1. system
     表只有一行记录，属于const特例，平时不会出现可以忽略

  2. const
     表示通过索引一次就找到，const用于比较primary key或者union索引。因为只是匹配一行数据，所以很快。
     例如将主键置于where列表中，mysql就能将该查询转换成一个常量:

     ```sql
     explain select * from tbl_emp where id = 1;
     +----+-------------+---------+------+---------------+------+---------+------+------+-------+
     | id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra |
     +----+-------------+---------+------+---------------+------+---------+------+------+-------+
     |  1 | SIMPLE      | tbl_emp | const| PRIMARY       | PRIMARY | 4    | const |   1 | NLL   |
     +----+-------------+---------+------+---------------+------+---------+------+------+-------+
     ```

  3. eq_ref

     唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或者唯一索引扫描

     ```sql
     explain select * from t1,t2 where t1.id = t2.id;
     +----+-------------+---------+------+---------------+------+---------+------+------+-------+
     | id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra |
     +----+-------------+---------+------+---------------+------+---------+------+------+-------+
     |  1 | SIMPLE      | t2			 | ALL	| PRIMARY       | NULL | NULL    | NULL |   639 | NLL   |
     |  1 | SIMPLE      | t1			 | eq_ref| PRIMARY      | PRIMARY | 4    | shared.t2.ID |   1 | NLL   |
     +----+-------------+---------+------+---------------+------+---------+------+------+-------+
     ```

     

  4. ref

     非唯一性索引扫描，返回匹配某个单独值的所有行，本质也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以属于查找和扫描的混合体。

     ```sql
     explain select * from tbl_emp a,tbl_dept b where a.deptid = b.id;
     +----+-------------+---------+------+---------------+------+---------+------+------+-------+
     | id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra |
     +----+-------------+---------+------+---------------+------+---------+------+------+-------+
     |  1 | SIMPLE      | b			 | ALL	| PRIMARY       | NULL | NULL    | NULL |   5 | NLL   |
     |  1 | SIMPLE      | a			 | ref| fk_dept_id      | fk_dept_id | 5    | db01.b.ID |   1 | NLL   |
     +----+-------------+---------+------+---------------+------+---------+------+------+-------+
     ```

     

  5. range
     只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。一般就是在where语句中出现between，<, >,in等查询。

     这种查询扫描索引比全表扫描好，因为他只是需要开始于索引的某一点，而结束另一点，不用扫描全部索引。

     ```sql
     explain select * from tbl_emp a where a.id > 2 and a.id < 5;
     +----+-------------+---------+------+---------------+------+---------+------+------+-------+
     | id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra |
     +----+-------------+---------+------+---------------+------+---------+------+------+-------+
     |  1 | SIMPLE      | a			 | range| PRIMARY       | PRIMARY | 4    | NULL |   1 | NLL   |
     +----+-------------+---------+------+---------------+------+---------+------+------+-------+
     ```

     

  6. index
     Full index scan, index与all区别为：index类型只是遍历索引树，通常比all快，因为索引文件通常比数据文件小。也就是说虽然all和index都是读全表，但是index是从索引中读取的，而all是从磁盘读取的。

     ```sql
     explain select id from tbl_emp;
     +----+-------------+---------+------+---------------+------+---------+------+------+-------+
     | id | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra |
     +----+-------------+---------+------+---------------+------+---------+------+------+-------+
     |  1 | SIMPLE      | tbl_emp | index| NULL	       | fk_dept_id | 5   | NULL |   8 | Using index|
     +----+-------------+---------+------+---------------+------+---------+------+------+-------+
     ```

     

- **possible_keys**
  显示可能应用在这张表中的索引，一个或者多个，查询涉及到的字段上若是存在索引，则该索引将被列出，但是不一定被实际查询使用。

- **Key**

  实际使用的索引，如果为null，则没有使用索引。查询中若是使用了覆盖索引，则该索引仅出现在key列表中。

- **ken_len**
  长度越短越好,显示的值为索引字段的最大可能长度，并非实际使用长度。

- **Ref**
  显示索引的那一列被使用了，哪些列或者常量被用于查找索引列上的值。

- **rows**
  根据表统计信息以及索引选用情况，大致估算出找到所需记录需要读取的行数。

- extra
  包含不适合在其他列显示但是十分重要的额外信息。





